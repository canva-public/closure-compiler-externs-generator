import { DirectoryJSON } from 'memfs';
import path from 'path';

type Exports = { [x: string]: Exports } | string;

function createPackageJson(args: {
  name: string;
  main?: string;
  exports?: Exports;
  types?: string;
  typings?: string;
  type?: 'commonjs' | 'module';
}): string {
  return JSON.stringify(
    {
      name: args.name,
      type: args.type,
      main: args.main,
      exports: args.exports,
      types: args.types,
      typings: args.typings,
    },
    null,
    2,
  );
}

/**
 * Creates a CommonJS package that relies on NodeJS's folder import logic to find `index.js`.
 * Types are resolved from imported filename (`index.js` -> `index.d.ts`).
 * Uses `module.exports = ...` style exports.
 */
function createPackageMainImplicit(
  nodeModulesPath: string,
  name: string,
): DirectoryJSON {
  const packagePath = path.join(nodeModulesPath, name);
  return {
    [`${packagePath}/package.json`]: createPackageJson({ name }),
    [`${packagePath}/index.js`]: 'module.exports = function foo() {}',
    [`${packagePath}/index.d.ts`]: 'export = foo;\ndeclare function foo(): void;',
  };
}

/**
 * Creates a CommonJS package with types supplied via `@types`.
 * Uses `module.exports.[export-name] = ...` style exports.
 */
function createPackageWithDTAndCJS(
  nodeModulesPath: string,
  name: string,
): DirectoryJSON {
  const typesName = `@types/${name}`;
  const packagePath = path.join();
  const typesPackagePath = path.join(nodeModulesPath, typesName);
  return {
    [`${packagePath}/package.json`]: createPackageJson({ name }),
    [`${packagePath}/index.js`]: 'module.exports.useFoo = () => {};',
    [`${typesPackagePath}/package.json`]: createPackageJson({
      name: typesName,
      types: './index.d.ts',
    }),
    [`${typesPackagePath}/index.d.ts`]: 'export = UntypedCjs;\ndeclare namespace UntypedCjs { function useFoo(): void; }',
  };
}

/**
 * Creates a CommonJS and ES module package with types supplied via `@types`.
 * CommonJS uses `module.exports.[export-name] = ...` style exports.
 */
function createPackageWithDTCJSAndESM(
  nodeModulesPath: string,
  name: string,
): DirectoryJSON {
  const typesName = `@types/${name}`;
  const packagePath = path.join();
  const typesPackagePath = path.join(nodeModulesPath, typesName);
  return {
    [`${packagePath}/package.json`]: createPackageJson({
      name,
      main: './main.js',
      exports: {
        './': {
          require: './main.js',
          import: './main.mjs',
        },
      },
    }),
    [`${packagePath}/index.js`]: 'module.exports.useFoo = () => {};',
    [`${packagePath}/index.mjs`]: 'export const useFoo = () => {};',
    [`${typesPackagePath}/package.json`]: createPackageJson({
      name: typesName,
      types: './index.d.ts',
    }),
    [`${typesPackagePath}/index.d.ts`]: 'export = UntypedCjs;\ndeclare namespace UntypedCjsAndEsm { function useFoo(): void; }',
  };
}

/**
 * Creates a CommonJS package with types location specified by the synonym `typings`.
 * Uses `module.exports.[export-name] = ...` style exports.
 */
function createpackageTypingsSynonym(
  nodeModulesPath: string,
  name: string,
): DirectoryJSON {
  const packagePath = path.join(nodeModulesPath, name);
  return {
    [`${packagePath}/package.json`]: createPackageJson({
      name,
      main: './main.js',
      typings: './main-types.d.ts',
    }),
    [`${packagePath}/main.js`]: `module.exports.foo = () => {};\nmodule.exports.bar = () => '';`,
    [`${packagePath}/main-types.d.ts`]: 'export function foo(): void;\nexport function bar(): string;',
  };
}

/**
 * Creates a CommonJS package with named exports.
 * Uses `module.exports.[export-name] = ...` style exports.
 */
function createpackageCJSNamedExports(
  nodeModulesPath: string,
  name: string,
): DirectoryJSON {
  const packagePath = path.join(nodeModulesPath, name);
  return {
    [`${packagePath}/package.json`]: createPackageJson({ name }),
    [`${packagePath}/main.js`]: `module.exports.foo = () => {};\nmodule.exports.bar = () => '';`,
    [`${packagePath}/main-types.d.ts`]: 'export function foo(): void;\nexport function bar(): string;',
  };
}

/**
 * Creates a CommonJS package with multiple entrypoints.
 * Modelled off [Preact 10.0.0](https://github.com/preactjs/preact/tree/10.0.0).
 * Uses `module.exports.[export-name] = ...` style exports.
 * @todo CURRENTLY NOT SUPPORTED, `./` entrypoint inherits symbols from `./extra`. Packages in the
 * wild may have missing symbols for deeper entrypoints such as `./extra`.
 */
function createpackageCJSMultipleEntrypoints(
  nodeModulesPath: string,
  name: string,
): DirectoryJSON {
  const packagePath = path.join(nodeModulesPath, name);
  return {
    [`${packagePath}/package.json`]: createPackageJson({
      name,
      main: './src/main.js',
      types: './src/main.d.ts',
    }),
    [`${packagePath}/src/main.js`]: 'module.exports.main = () => {};',
    [`${packagePath}/src/main.d.ts`]: 'export = Scoped_ExportsMultipleCJS;\ndeclare namespace Scoped_ExportsMultipleCJS { function main(): void; }',
    [`${packagePath}/extra/package.json`]: createPackageJson({
      name: 'extra',
      main: './src/extra.js',
      types: './src/extra.d.ts',
    }),
    [`${packagePath}/extra/src/extra.js`]: 'module.exports.extra = () => {};',
    [`${packagePath}/extra/src/extra.d.ts`]: 'export = Scoped_ExportsMultipleCjs_Extra;\ndeclare namespace Scoped_ExportsMultipleCjs_Extra { function extra(): void; }',
  };
}

/**
 * Creates a CommonJS and ES module package with multiple entrypoints.
 * Modelled off [Preact 10.5.15](https://github.com/preactjs/preact/tree/10.5.15).
 * CommonJS uses `module.exports.[export-name] = ...` style exports.
 * @todo CURRENTLY NOT SUPPORTED, `./` entrypoint inherits symbols from `./extra`. Packages in the
 * wild may have missing symbols for deeper entrypoints such as `./extra`.
 */
function createpackageCJSAndESMMultipleEntrypoints(
  nodeModulesPath: string,
  name: string,
): DirectoryJSON {
  const packagePath = path.join(nodeModulesPath, name);
  return {
    [`${packagePath}/package.json`]: createPackageJson({
      name,
      main: './src/main.js',
      types: './src/main.d.ts',
      exports: {
        './': {
          import: './src/main.mjs',
          require: './src/main.js',
        },
        './extra': {
          import: './extra/src/extra.mjs',
          require: './extra/src/extra.js',
        },
      },
    }),
    [`${packagePath}/src/main.mjs`]: 'export const main = () => {};',
    [`${packagePath}/src/main.js`]: 'module.exports.main = () => {};',
    [`${packagePath}/src/main.d.ts`]: 'export = Scoped_ExportsMultipleCJS;\ndeclare namespace Scoped_ExportsMultipleCJS { function main(): void; }',
    [`${packagePath}/extra/package.json`]: createPackageJson({
      name: 'extra',
      main: './src/extra.js',
      types: './src/extra.d.ts',
    }),
    [`${packagePath}/extra/src/extra.mjs`]: 'export const extra = () => {};',
    [`${packagePath}/extra/src/extra.js`]: 'module.exports.extra = () => {};',
    [`${packagePath}/extra/src/extra.d.ts`]: 'export = Scoped_ExportsMultipleCjs_Extra;\ndeclare namespace Scoped_ExportsMultipleCjs_Extra { function extra(): void; }',
  };
}

/**
 * Creates a ES module package with multiple entrypoints.
 * Types are resolved from imported filename (`extra.js` -> `extra.d.ts`).
 * @todo CURRENTLY NOT SUPPORTED, `exports` field logic is not processed.
 */
function createpackageESMMultipleEntrypoints(
  nodeModulesPath: string,
  name: string,
): DirectoryJSON {
  const packagePath = path.join(nodeModulesPath, name);
  return {
    [`${packagePath}/package.json`]: createPackageJson({
      name,
      type: 'module',
      exports: {
        './': './main.js',
        './extra': './extra.js',
      },
    }),
    [`${packagePath}/main.js`]: 'export function main() {}',
    [`${packagePath}/main.d.ts`]: 'export function main(): void;',
    [`${packagePath}/extra.js`]: 'export function extra() {}',
    [`${packagePath}/extra.d.ts`]: 'export function extra(): void;',
  };
}

/**
 * Creates a ES module package with a single entrypoint using the `exports` sugar shorthand.
 * Types are resolved from imported filename (`main.js` -> `main.d.ts`).
 * @todo CURRENTLY NOT SUPPORTED, `exports` field logic is not processed.
 */
function createpackageESMSingleWithSugar(
  nodeModulesPath: string,
  name: string,
): DirectoryJSON {
  const packagePath = path.join(nodeModulesPath, name);
  return {
    [`${packagePath}/package.json`]: createPackageJson({
      name,
      type: 'module',
      exports: './main.js',
    }),
    [`${packagePath}/main.js`]: `export function foobar() {}\nexport const barfoo = '';`,
    [`${packagePath}/main.d.ts`]: 'export function foobar(): void;\nexport const barfoo: string;',
  };
}

/**
 * Creates a ES module package with a single entrypoint.
 * Types are resolved from imported filename (`main.js` -> `main.d.ts`).
 * @todo CURRENTLY NOT SUPPORTED, `exports` field logic is not processed.
 */
function createpackageESMSingle(
  nodeModulesPath: string,
  name: string,
): DirectoryJSON {
  const packagePath = path.join(nodeModulesPath, name);
  return {
    [`${packagePath}/package.json`]: createPackageJson({
      name,
      type: 'module',
      exports: {
        './': './main.js',
      },
    }),
    [`${packagePath}/main.js`]: `export function foobar() {}\nexport const barfoo = '';`,
    [`${packagePath}/main.d.ts`]: 'export function foobar(): void;\nexport const barfoo: string;',
  };
}

/**
 * Creates an in-memory representation of a `node_modules` file tree.
 * At time of writing TypeScript has yet to formalise how CJS and ESM types are handled.
 * @todo Revisit how ESM and dual mode packages are typed once `node12` module resolution available.
 */
export function createNodeModules(basePath: string): DirectoryJSON {
  const nodeModulesPath = path.join(basePath, 'node_modules');
  return {
    ...createPackageMainImplicit(nodeModulesPath, 'main-implicit'),
    ...createPackageWithDTAndCJS(nodeModulesPath, 'untyped-cjs'),
    ...createPackageWithDTCJSAndESM(nodeModulesPath, 'untyped-cjs-and-esm'),
    ...createpackageTypingsSynonym(nodeModulesPath, 'typings-synonym'),
    ...createpackageCJSNamedExports(nodeModulesPath, 'cjs-named-exports'),
    ...createpackageCJSMultipleEntrypoints(
      nodeModulesPath,
      '@scoped/exports-multiple-cjs',
    ),
    ...createpackageCJSAndESMMultipleEntrypoints(
      nodeModulesPath,
      '@scoped/exports-multiple-cjs-and-esm',
    ),
    ...createpackageESMMultipleEntrypoints(
      nodeModulesPath,
      '@scoped/exports-multiple-esm',
    ),
    ...createpackageESMSingleWithSugar(
      nodeModulesPath,
      '@scoped/exports-sugar-esm',
    ),
    ...createpackageESMSingle(nodeModulesPath, '@scoped/exports-sugarfree-esm'),
  };
}
